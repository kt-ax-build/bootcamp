# Agile & AI Agentic Coding 동행

## Agile 방법론의 핵심

- **적응성과 유연성**: 애자일은 변화가 잦고 불확실성이 높은 환경에서 신속하게 방향을 전환하고 적응할 수 있도록 설계된 개발 및 조직 운영 방식입니다.
- **반복적 개발 및 빠른 가치 제공**: 작은 단위의 소프트웨어를 빠르게 출시하며, 고객 피드백을 반영해 지속적으로 개선합니다.
- **수평적이고 협업 중심의 조직 문화**: 모든 구성원이 자율적으로 업무를 수행하고, 효율적인 의사결정 구조를 지향합니다.
- **혁신과 생산성의 극대화**: 변화에 빠르게 대응해 혁신을 유도하고, 비용 및 시간 낭비를 최소화합니다.

## AI Agentic Coding의 특징

- **AI 중심의 개발 자동화**: AI 에이전트는 주어진 목표를 해석, 세부 작업으로 분해, 구현, 테스트, 성능 평가 등 전체 소프트웨어 개발 프로세스를 주도할 수 있습니다.
- **지속적 자기개선과 자율적 실행**: AI 에이전트는 작업 결과를 스스로 피드백·반영하며, 반복적으로 코드를 개선해 더욱 빠른 개발 주기가 가능합니다.
- **사람-에이전트 협업 구조**: 개발자는 멀티 에이전트가 수행하는 일의 목표 설정·감독에 집중하고, 반복적·루틴한 일은 AI가 담당하여 창의적 문제 해결에 더 많은 시간을 투자할 수 있습니다.
- **생산성, 유지보수성, 코드 품질 향상**: 반복 및 구조적 작업이 자동화되면서 개발 효율 및 소프트웨어 품질이 크게 향상됩니다.

## 두 패러다임의 동행 이유

|                 | 애자일의 목적             | Agentic Coding의 역할            | 동행의 시너지                       |
| --------------- | ------------------- | ----------------------------- | ----------------------------- |
| **적응성과 빠른 피드백** | 변화에 신속히 대응, 반복적 개선  | 신속한 코드 생성과 테스트, 피드백 자동화       | 개발주기 대폭 단축, 실시간 문제 해결 가능  |
| **협업과 자율성**     | 팀의 자기 조직화와 수평적 협업   | AI가 루틴 작업 자동화, 개발자는 고차원 문제 집중 | 창의성·효율성 동시 향상, 업무 만족도 증대  |
| **가치 중심 개발**    | 고객 요구/가치의 우선 반영     | 데이터 분석, 실행, 모니터링 자동화          | 고객 요구 반영 속도와 정확도 증가       |
| **혁신과 미래 지향성**  | 기존 방식의한계 극복 및 혁신 도입 | LLM, 에이전트 기반 신기술의 실무 적용       | AI 기술과 조직문화가 상호 촉진, 지속 혁신 |

## Vibe Coding vs Agentic Coding

!!!info "원본 문서 및 논문 참고"
    Link: [[별첨] Vibe Coding vs Agentic Coding](./vibe-vs-agentic.md)

| **특징**              | **Vibe Coding (바이브 코딩)**                                                                                                                                        | **Agentic Coding (에이전틱 코딩)**                                                                                                                                                 |
| ------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **정의**              | - 개발자가 LLM 기반 서비스와 반복적인 프롬프트 및 전략적 방향 지시 기반으로 Software 개발                                                                                                       | - 고수준 목표를 독립적으로 해석하고, 작업을 하위 작업으로 분해하며, 실행 전략을 계획<br>- 실시간 피드백 및 결과에 따라 동작을 조정하는 에이전틱 AI 시스템 기반으로 Software Lifecycle 관리                                                      |
| **핵심 철학**           | - 직관적인 인간-AI 공동 생성 및 파트너십<br>- 개발자가 고수준의 "바이브"와 반복적인 피드백을 통해 AI 활용                                                                                              | - 자율적이거나 반자율적인 작업 실행자로서의 AI 활용<br>- 개발자는 복잡한 목표를 위임하며, AI는 고수준의 인간 감독 하에 계획 수립 및 실행                                                                                          |
| **개발자 역할**          | - **고수준 코디네이터**, 의도 설계자, 크리에이티브 디렉터, 탐색자<br>- "무엇을 할 것인가"를 강조                                                                                                   | - **시스템 설계자**, 전략 기획자, 감독 검토자, 윤리적 게이트키퍼<br>- 직접적인 구현보다는, 오케스트레이션 관점에서 접근                                                                                                    |
| **상호작용 모델 및 워크플로우** | - 고수준 요청, LLM 코드 생성, 개발자 검토 및 수정의 **반복적인 프롬프트-응답 루프**    <br>- 실행 및 최종 유효성 검사는 개발자가 관리하는 표준 개발 환경에서 이루어지며, 워크플로우는 탐색적이고 비선형적                                    | - 에이전트가 고수준 목표를 해석하고, 작업 계획을 세우며, 도구를 활용하고, 실행 및 반복하며, 개발 및 수정을 수행<br>- 개발자의 역할은 미션 정의, 시스템 동작 모니터링 및 결과 유효성 검사로 변화하며, 워크플로우는 작업 계획, 상태 관리 및 재귀적 피드백 루프를 기반으로 하는 구조화         |
| **Semiotics**       | - 전통적인 프로그래밍 언어 대신 **자연어, 고수준 설명, 시각적 목업** 등을 LLM에 대한 입력으로 사용<br>- 인간과 기계 간의 공동 구성적 의미 부여 모델을 반영하는 반복적인 대화 프로세스                                                 | - 에이전트가 고수준 자연어 프롬프트를 구문 분석하여 여러 파일, 계층 또는 구성 요소를 아우르는 목표를 해석                                                                                                                |
| **실행 모델**           | - LLM은 IDE 또는 웹 기반 환경 내에서 개발자 시작 프롬프트 기반 상호작용을 통해 코드 생성 엔진으로 작동<br>    <br>- 실행은 Code 생성 파이프라인과 명시적으로 분리                                                        | - **컨테이너화된 정책 제약 런타임 환경** (e.g. Docker) 을 통합하여 자율 에이전트가 인간의 개입 없이 코드를 생성, 실행, 테스트 및 반복적으로 개선하는 실행 프로세스로 구현                                                                   |
| **자율성 및 피드백 루프**    | - **인간 중심 제어**<br>    - 개발자가 유효성 검사, 오류 감지 및 반복적인 개선을 담당하는 유일한 에이전트입<br>    - LLM은 자체 평가 기능이 없는 상태 비저장 코드 합성 엔진으로 작동하며, 피드백 루프는 개발자에 의해 시스템 외부에서 중재             | - **목표 지향 자율성**<br>    - 에이전트는 계획, 실행, 테스트, 평가 및 수정 반복을 포함하는 다단계 피드백 루프를 통해 작동하며, 단계 간에 인간의 프롬프트 불필요<br>    - 강화 학습, 상징적 계획 및 블랙박스 평가 전략을 활용하여 코딩 세션 내에서 지속적인 개선을 목표로 함      |
| **안전 및 설명 가능성**     | - **제한된 안전 장치**<br>    - 런타임 적용 메커니즘이 부족하여 안전 및 설명 가능성이 외부화되는 문제 발생<br>    - LLM은 의사 결정 프로세스를 기록하거나 정당화할 수 없어 신뢰를 저해하며, 개발자는 코드 생성 후 3rd. Party 외부 정적 분석 도구에 의존 | - **임베디드 안전 장치**<br>    - 자원 및 네임스페이스 격리, 로깅 훅, 롤백 트리거와 같은 내장된 안전 제약 조건으로 설계<br>    - Claude Code 및 Amazon Kiro 와 같은 도구는 모든 의사 결정 노드와 코드 변환을 기록하여 **투명한 실행 및 Audit 가능성**을 제공 |
| **프롬프트 엔지니어링**      | - 창의적 생성을 위한 **정밀성 및 컨텍스트**<br>- 의도 중심적이고, 컨텍스트에 민감하며, 탐색적인 프롬프트에 중점                                                                                            | - 계층적이고 다단계 지침<br>- 작업 연결, 실행 준비된 프롬프트, 상호작용적 피드백을 지원                                                                                                                        |
| **검토 및 디버깅**        | - **수동적, 반복적, 프롬프트 기반 유효성 검사**<br>- 개발자가 문제를 식별하고 해결하는 데 적극적인 역할을 하며, AI는 프롬프트 기반으로 오류 수정 기여                                                                    | - **자율적 디버깅 및 런타임 검증**<br>- 에이전트는 런타임 평가 및 내부 로깅 시스템을 통해 자체적으로 정확성을 검증하며, 오류 처리 프로토콜 (롤백, 패치 대체, 재시도 논리) 을 포함                                                                |
| **주요 사용 사례**        | - 개인 포트폴리오 웹사이트 개발, 대화형 데이터 시각화 대시보드, 할 일 목록 웹 애플리케이션<br>- 프론트엔드 구성 요소에 대한 단위 테스트 생성<br>- 프레임워크 탐색 및 온보딩, 창의적 탐색, 빠른 프로토타이핑, 새로운 기술 학습                          | - 자동화된 코드베이스 리팩토링, 루틴 종속성 업데이트, 회귀 버그 수정<br>- CI/CD 파이프라인 자동화, 자동화된 보안 감사, 대규모 코드 마이그레이션, 종단 간 기능 구현<br>- 정확성, 추적성 및 자동화가 필요한 엔터프라이즈급 작업                                     |
| **주요 한계**           | - **모델 출력의 불투명성**<br>- 생산 지향 개발 시스템과의 낮은 호환성, 장기 코드 품질 저하 (기술 부채 축적).                                                                                           | - **에이전트에 대한 과도한 의존** (기술 위축)<br>- 자동 오류 전파 (논리적 오류 또는 회귀)<br>- 보안 취약점 관리 필요 (프롬프트 주입, 비밀 유출)                                                                                |

## Vibe Coding 단계적 진화

!!!note "이번 교육 과정에서는, LV3 의 Vibe Coding 과 LV4 의 Spec-Driven 개발 통합 일부에 대해서 다룹니다."

| **Level**                | **AI Coverage**                                                 | **개발자 역할**                                                  | **활용 Tools**                                                                        |
| ------------------------ | --------------------------------------------------------------- | ----------------------------------------------------------- | ----------------------------------------------------------------------------------- |
| LV1: Copy & Paste Assist | Code Snippet 생성                                                 | - AI Code 제안 내역 검토<br>    <br>- 개발 활용 및 테스트 수행 후 Product 적용 | Claude Desktop, ChatGPT, Gemini 등                                                   |
| LV2: Sandbox 기반 개발       | Code 생성 및 격리 환경 기반 실행                                           | - AI Code 작성 및 테스트 내역 검토<br>    <br>- 개발 활용 및 Product 적용    | Claude Artifacts 등                                                                  |
| LV3: IDE 통합 Agent        | Code File 다중 생성, 편집 및 테스트 수행하며, PR 작성까지 가능 (MCP Tool Server 통합) | - AI 개발 내역 및 PR 내용 검토<br>    <br>- Product 적용               | Cursor, Windsurf, Kiro 등                                                            |
| LV4: Workflow 자동화        | Spec 기반 개발, 테스트를 수행하며, 배포 및 모니터링까지 자동화                          | - AI 개발, 테스트 및 배포 모니터링 결과 검토<br>    <br>- Product 적용        | _AI Coding Tool (Claude Code, Gemini CLI) + DevSecOps Tool Chain 통합 Pipeline 구축 필요_ |